
module Test {

type Enum = enum { A = 1, B = 2, C = 4 };
type Exception = exception;
type MatchState = __library_type("::hilti::rt::regexp::MatchState");
type TypeInfo = __library_type("const ::hilti::rt::TypeInfo*");

type Struct = struct {
    string s;
    int<64> i;
};

type Union = union {
    string s,
    int<64> i
};

public type TestTypes = struct {
    addr ad;
    any an;
    bool bo;
    bytes by;
    iterator<bytes> bi;
    Enum en;
    error er;
    exception ex;
    # method void test(); # Can't test - won't be included into type info.
    interval in_;
    MatchState li;
    map<uint<64>, string> ma;
    iterator<map<uint<64>, string>> mai;
    net ne;
    optional<string> op;
    port po;
    real re;
    regexp rx;
    result<string> rs;
    set<string> se;
    iterator<set<string>> sei;
    int<8> i8;
    int<16> i16;
    int<32> i32;
    int<64> i64;
    stream st;
    iterator<stream> sti;
    view<stream> stv;
    string str;
    strong_ref<Struct> sr;
    Struct stru;
    time ti;
    tuple<a: int<32>, string, c: bool> tu;
    Union un;
    uint<8> ui8;
    uint<16> ui16;
    uint<32> ui32;
    uint<64> ui64;
    vector<string> ve;
    iterator<vector<string>> vei;
    value_ref<Struct> vr;
    # void vo; # can't test - cannot be used as a struct field
    weak_ref<Struct> wr;
};

public type TestOptionals = struct {
    string opt_set &optional;
    string opt_unset &optional;
};

global Vector = vector("11", "22", "33");
global Map = map(1: "foo-1", 2: "foo-2");
global Set = set("aaa", "bbb", "ccc");
global Bytes = b"bytes";
global Stream = stream(b"stream");

public function tuple<strong_ref<TestTypes>, strong_ref<TestTypes>, TypeInfo> makeTestTypes() {
    local S = new Struct;
    S.s = "string";
    S.i = 42;

    local Union U;
    U.i = 42;

    local re = /abc/ &nosub;
    local MatchState MS = re.token_matcher();
    local Exception E;

    local TestTypes x = [
        $ad = 1.2.3.4,
        $an = "any",
        $bo = True,
        $by = b"bytes",
        $bi = begin(Bytes),
        $en = Enum::B,
        $er = error("error"),
        $ex = E,
        $in_ = interval(5.0),
        $li = MS,
        $ma = Map,
        $mai = begin(Map),
        $ne = 1.2.3.4/16,
        $op = "optional",
        $po = 1234/udp,
        $re = 3.14,
        $rx = /foo/,
        $rs = "result",
        $se = Set,
        $sei = begin(Set),
        $i8 = -8,
        $i16 = -16,
        $i32 = -32,
        $i64 = -64,
        $st = Stream,
        $sti = begin(Stream),
        $stv = Stream,
        $str = "string",
        $sr = S,
        $stru = *S,
        $ti = time(1295415110.5),
        $tu = (123, "string", True),
        $un = U,
        $ui8 = 8,
        $ui16 = 16,
        $ui32 = 32,
        $ui64 = 64,
        $ve = Vector,
        $vei = begin(Vector),
        $vr = S,
        $wr = S
    ];

    return (new (x), new TestTypes, typeinfo(TestTypes));
}

public function tuple<strong_ref<TestOptionals>, TypeInfo> makeTestOptionals() {
    local TestOptionals x = [
        $opt_set = "yes"
    ];

    return (new (x), typeinfo(TestOptionals));
}

}
